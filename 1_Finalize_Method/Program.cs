using static System.Net.Mime.MediaTypeNames;

namespace _1_Finalize_Method
{
    internal class Program
    {
        static void CreateObjects()
        {
            FinalizeObject[] obj = new FinalizeObject[30];
            for (int i = 0; i < 30; i++)
                obj[i] = new FinalizeObject(i.ToString());
            Console.WriteLine("Создано 30 объектов!");
        }
        static void Main(string[] args)
        {
            CreateObjects();
            GC.Collect();
            // Обратите внимание, что даже после завершения метода CreateObjects и
            // соответственно удаления из стека ссылки на объект Person в куче,
            // может не последовать немедленного вызова деструктора. Лишь при завершении
            // всей программы гарантировано произойдет очистка памяти.
            // Однако с .NET 5 и в последующих версиях при завершении программы
            // деструкторы не вызываются. Поэтому в программе выше для более быстрой очистки
            // памяти применяется метод GC.Collect и для гарантированного вызова
            // деструктора устанавливается задержка с помощью вызова Console.Read(),
            // который ожидает от пользователя ввода.
            // После завершения приложения  будет активирована сборка мусора, 
            // которая удалит 30 объектов класса FinalizeObject, при этом запустится деструктор.
            Console.Read();
        }
    }
    class FinalizeObject
    {
        public string id { get; set; }

        public FinalizeObject(string id)
        {
            this.id = id;
        }

        ~FinalizeObject()
        {
            Console.WriteLine("Объект {0} уничтожен", id);
            // Освобождаем неуправляемые ресурсы
        }

        /*        
        При очистке сборщик мусора вызывает не деструктор, а метод Finalize класса FinalizeObject
         Метод Finalize уже определен в базовом для всех типов классе Object, однако данный метод нельзя переопределить. 
         И фактическая его реализация происходит через создание деструктора.
*/
        //protected override void Finalize()
        //{
        //    try
        //    {
        //        // здесь идут инструкции деструктора
        //    }
        //    finally
        //    {
        //        base.Finalize();
        //    }
        //}

    }
    //Стоит отметить, что точное время вызова деструктора не определено. Кроме того, при финализации двух
    //связанных объектов порядок вызова деструкторов не гарантируется.
    //И здесь мы можем столкнуться со следующей проблемой: а что если нам немедленно надо вызвать
    //деструктор и освободить все связанные с объектом неуправляемые ресурсы? В этом случае мы можем
    //использовать второй подход - реализацию интерфейса IDisposable.
}